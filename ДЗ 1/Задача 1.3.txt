3. Подотрезок с максимальной суммой
Ограничение времени	2 секунды
Ограничение памяти	893.5 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Сложная часть (необходимо на "отл")

Реализуйте функцию find_max_sum_segment,
выполняющую поиск подотрезка длины k с максимальной суммой в целочисленном массиве array.
Функция должна возвращать максимальное значение суммы.
Например, у массива array = [5, 3, -6, 1] есть 3 подотрезка длины k = 2 с суммами [8, -3, -5] соответственно, в этом случае функция должна вернуть число 8.

Шаблон решения:


import numpy as np
import typing as tp

def find_max_sum_segment(array: tp.List[int], k: int) -> int:    
    return ...
В реализации разрешается создавать объекты размерности два.
Запрещается использовать циклы, а также готовую функцию np.cumsum.

Подсказка. Задачу можно решать разными способами.
Можно обратить внимание на функции для генерации треугольных матриц в пакете numpy и воспользоваться векторно-арифметическими операциями.
Можно попробовать сделать специальную бинарную матрицу и также воспользоваться векторно-арифметическими операциями, включая матричные операции.

Присылать нужно только код функции с подключением необходимых библиотек.
Использовать библиотеки, которых нет в шаблоне, запрещается.

Решение:
import numpy as np
import typing as tp

def find_max_sum_segment(array: tp.List[int], k: int) -> int:
    if (k==1):
        return int(max(array))
    else:
        n= len(array) #длина строки
        array_2=np.asarray(array)
        if (array_2[np.nonzero(array_2)].shape[0]==n):     
            A = np.zeros((k))
            A[...] = 1 # матрица из k единиц
            C=A.reshape((-1, 1)) * array # продублировали array k раз
            C=np.triu(C) # оставили только верхнетреугольную матрицу размера k*n
            O=np.arange(k)
            R=np.arange(n)+1 # массив целых от 1 до n включительно
            E=C[np.nonzero(C)] # убрали все нули и объединили все строки в 1
            def f1(i,j):
                 return (i*(i+1))/2
            W=np.fromfunction(f1, (n,1), dtype=int).T # числа 0 1 3 6 10 15 21 ...
            W_2=np.delete(R*n + W*(-1), R[k-2:n-1]).astype("int") # оставляем первые k-1 чисел, поэтому случай k=1 рассматривается отдельно
            W_5=np.delete(R*n + W*(-1), R[k-1:n-1]).astype("int") # добавили еще 1 элемент с конца относительно W_2
            W_5=np.delete(W_5, 0).astype("int") # убрали 0-й элемент
            A_2= np.zeros((k-1))
            A_2[...] = 1# матрица из k-1 единиц
            W_3=A_2.reshape((-1, 1)) * W_5
            W_3=np.triu(W_3).T
            W_4=W_3[np.nonzero(W_3)].astype("int")
            E_3=np.insert(E,W_4,0) # 2n-1 3n-3 3n-3 4n-6 4n-6 4n-6  если дополняем нулями справа
            H=np.split(E_3,k)
            list_0 = [np.zeros((n),dtype=int)]
            U=np.stack( H, axis=0 )
            I= U.sum(axis=0) # сумма строк
            J=np.delete(I, R[n-k:n-1]) # удаление лишних элементов
            answ= int(max(J))
            print(answ)
            return answ
        else:
            array[array.index(0)] = -1000000
            x= find_max_sum_segment(array, k)
        return x