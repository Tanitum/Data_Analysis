2. Ближайшие соседи
Ограничение времени	6 секунд
Ограничение памяти	512.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Допустим, вам необходимо разработать автоматический классификатор, который умеет различать котиков от песиков.
Как его реализовать? 
Можно посмотреть на характеристики каждого животного: вес, длина хвостика, объем туловища, а можно посмотреть и на фотографию.
Тем самым для животного получится некоторый вектор x, который принадлежит R^d.
Давайте сравним этот вектор с другими векторами котиков и песиков, которых мы видели ранее.
Если вектор x окажется ближе к котикам, то мы скажем, что перед нами котик, иначе — песик.

Обычно среди всего множества известных нам котиков и песиков берут k штук, для которых соответствующие им векторы лежат ближе всего к нашему вектору x.
Эти k штук векторов называются ближайшими соседями. Можете подумать, почему часто плохо брать k=1.

К самой классификации мы перейдем позже, а сейчас давайте закрепим навык поиска ближайших соседей.
Реализуйте функцию find_nearest_points, выполняющую поиск k ближайших соседей точек из множества B среди точек из множества A.
На вход функции подаётся

матрица A размерности n×d,
матрица B размерности m×d,
число k — количество соседей.
В матрице A по строкам записаны n точек из пространства 
R^d, аналогично описаны m точек в матрице B.
Функция find_nearest_points должна возвращать матрицу C размерности m×k,
каждая строка j (1 меньше или равно j меньше или равно m) которой состоит из 
k индексов pji
​(1⩽pji ⩽n,1⩽i⩽k) ближайших точек из 
A к точке Bj (по евклидовой метрике).

Шаблон решения:


import numpy as np
import typing as tp


def find_nearest_points(A: np.ndarray, B: np.ndarray, k: int) -> np.ndarray:    
    return ...
Рассмотрим следующий пример:

>>> A = np.array([
...   [0, 0],
...   [1, 0],
...   [2, 0]
... ])
>>>
>>> B = np.array([
...   [0, 1],
...   [2, 1]
... ])
>>>
>>> find_nearest_points(A, B, 2)
array([[1, 2],
       [3, 2]])
Для точки (0,1) ближайшей из списка точек A является точка 
(0,0), которая имеет индекс 1 (в данной задаче индексация точек начинается с 1).
Второй по расстоянию будет точка (1,0) с индексом 2, поэтому первая строчка матрицы,
которая получена в результате работы функции, равна [1,2].

Гарантируется, что в тестах все попарные расстояния между точками различны.

В реализации разрешается создавать объекты размерности три.
Запрещается использовать циклы, а также функции из пакета numpy.linalg.

Присылать нужно только код функции с подключением необходимых библиотек.
 Использовать библиотеки, которых нет в шаблоне, запрещается.
 
Решение:
import numpy as np
import typing as tp

def find_nearest_points(A: np.ndarray, B: np.ndarray, k: int) -> np.ndarray:
    # A размерности n×d, B размерности m×d
    n= A.shape[0]
    d= A.shape[1]
    m= B.shape[0]
    square_dist = np.sum((B[:,np.newaxis,:] - A[np.newaxis,:,:])** 2,axis=-1) # матрица с попарными квадратами расстояний
    nearest = np.argsort(square_dist, axis=1)
    nearest_2=nearest+1 # индексы в ответе идут не с 0, а с 1
    R=np.linspace(k, n-1,n-k).astype("int") # числа с индексами от k до n-1
    answ =np.delete(nearest_2,R,1) 
    return answ