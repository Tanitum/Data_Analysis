A. Страна котиков
Ограничение времени	5 секунд
Ограничение памяти	893.5 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Легкая часть (достаточно на "хор")

Представьте, что вы министр образования страны котиков. Вам нужно решить, какие школы лучше: маленькие или большие.
Вы решили, что нужно сравнить их по результатам единого кошачьего экзамена (ЕКЭ).
Предлагается посмотреть на средний результат по школам: отсортировать по нему и сделать выводы исходя из топ 10 лучших школ.

Вам дан датасет cat_exam_data.csv со следующими полями:

school 
−
− номер школы;
test_score 
−
− результат одного ученика из этой школы;
number_of_students 
−
− кол-во учеников в школе.
Задача состоит из 10 пунктов, под каждый из которых предусмотрена соответствующая функция в классе CatExam:

Загрузите датасет с результатами экзамена. Используйте функцию pd.read_csv.
Посмотрите на первые пять строк таблицы. Это можно сделать с помощью метода head.
Проверьте, есть ли пропуски в данных (NaN). Вам могут помочь методы isna и dropna.
Необходимо вернуть список из названий колонок таблицы, в которых есть пропуски.
Удалите строки таблицы, в которых есть пропуски. Следующие пункты выполняйте с данными без пропусков.
Посчитайте описательные статистики (среднее, мин, макс, и тд.) по колонкам в таблице с помощью одной функции.
Посчитайте сколько котиков получили 100 баллов.
Выведите подробную информацию о школах, где есть хотя бы один котик, получивший 100 баллов на ЕКЭ.
Отсортируйте эти школы по количеству стобалльников и номеру школы в порядке убывания.
Колонку с количеством стобалльников нужно назвать 'cnt_100'. Из функции необходимо вернуть pandas.DataFrame со столбцами ['school', 'number_of_students', 'cnt_100'].
Подсказка: Могут помочь методы groupby, sort_values, transform, reset_index и count.
Посчитайте средний результат каждой из школ. Рассматриваем все школы, не только со стобальниками.
Отсортируйте школы по среднему результату и посмотрите на топ 10 лучших школ по этому параметру.
Из функции необходимо вернуть pandas.DataFrame со столбцами ['school', 'test_score', 'number_of_students']. Подсказка: Может помочь метод mean.
Ожидаем, что внизу рейтинга будут только большие школы, давайте это проверим. Посмотрите теперь на 10 худших школ.
Сгруппируйте учеников в зависимости от типа школы, получив тем самым два датасета. Будем считать, что школа небольшая, если в ней не более 1000 учеников. Постройте гистограммы оценок этих двух выборок на одном графике, установив параметры:
bins=10 
−
− число бинов гистограммы;
alpha=0.5 
−
− прозрачность бинов; Оси и сам график должны быть подписаны, должна быть легенда, которая различает две гистограммы. Функция должна вернуть matplotlib.axes.Axes, на котором рисовался график (в шаблоне возвращаемое значение уже есть). Вызывать plt.show() нельзя, этот метод сбрасывает текущий холст.
Шаблон решения:


import pandas as pd
import matplotlib.pyplot as plt
import typing as tp
from matplotlib.axes import Axes


class CatExam:
    def __init__(self, path_to_df: str="cat_exam_data.csv"): # task0
      self.df = # read df

    def task1(self) -> pd.DataFrame:
      return ...
    
    def task2(self) -> tp.List[str]:
      return ...

    def task3(self) -> pd.DataFrame:
      return ...
    
    def task4(self) -> pd.DataFrame:
      return ...
    
    def task5(self) -> int:
      return ...
    
    def task6(self) -> pd.DataFrame:
      return ...

    def task7(self) -> pd.DataFrame:
      return ...

    def task8(self) -> pd.DataFrame:
      return ...

    def task9(self) -> Axes:
      ...
      return plt.gca()
Присылать нужно только код класса с подключением необходимых библиотек. Использовать библиотеки, которых нет в шаблоне, запрещается.
Во время тестирования создается только один объект класса решения. Все подзадачи запускаются по порядку.
Решение будет протестировано на двух наборах тестов. В случае ошибок на первом наборе вы сможете увидеть данные теста, данные вторых тестов скрыты. Итоговые баллы выставляются за каждый пройденный тест.








B. YouTube
Ограничение времени	15 секунд
Ограничение памяти	512.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Легкая часть (достаточно на "хор")

Задача заключается в работе с данными о трендах на YouTube. В этом вам поможет библиотека seaborn, которая была рассмотрена на одной из последних лекций.

Задача состоит из 7 пунктов, под каждый из которых предусмотрена соответствующая функция в классе YouTube:

Часть I. Подготовка данных

Скачайте файл RUvideos_short.csv с данными о видео в российском сегменте Youtube с 14 ноября по 21 ноября 2017 года. Полная версия данных доступна на kaggle.
Прочитайте данные с помощью библиотеки pandas. В колонке trending_date записана дата. При чтении таблицы распознайте ее правильным образом.

Замечание. Часто считывание дат — головная боль аналитика.

Верните считанную таблицу с колонкой trending_date типа datetime64
В таблице много лишних данных. Оставьте следующие столбцы:
trending_date 
−
− дата в формате год-день-месяц;
category_id 
−
− категория видео (названия приведены в файле RU_category_id.json, но в этой задаче они не пригодятся);
views 
−
− количество просмотров видео;
likes 
−
− количество лайков;
dislikes 
−
− количество дислайков;
comment_count 
−
− количество комментариев.
Из даты оставьте только день. Для этого можно у каждого объекта даты взять поле day - здесь вам поможет метод apply. Верните получившуюся таблицу.

Часть II. Некоторая визуализация

Постройте ящики с усами на каждый день по количеству просмотров.
Насколько хороший получился график в прошлом пункте? Исправьте этот недостаток, установив некоторое значение.
Постройте jointplot по всем данным для количества просмотров по горизонтальной оси и количества лайков по вертикальной.
Насколько информативен график из прошлого пункта? Исправьте этот недостаток.
Шаблон решения:


from datetime import datetime
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.figure import Figure
import typing as tp


class YouTube:
    def __init__(self, path_to_df: str = "RUvideos_short.csv"):
        self.df = ...

    def task1(self) -> pd.DataFrame:
        return ...

    def task2(self) -> pd.DataFrame:
        return ...

    def task3(self) -> Figure:
        ...
        return plt.gcf()

    def task4(self) -> Figure:
        ...
        return plt.gcf()

    def task5(self) -> Figure:
        ...
        return plt.gcf()

    def task6(self) -> Figure:
        ...
        return plt.gcf()
Присылать нужно только код класса с подключением необходимых библиотек. Использовать библиотеки, которых нет в шаблоне, запрещается.
Во время тестирования создается только один объект класса решения. Все подзадачи запускаются по порядку.
Все функции для пунктов с графиками должны возвращать matplotlib.figure.Figure, на котором рисовался график. В шаблоне уже есть пример как это сделать через plt.gcf(), но при этом нельзя вызывать plt.show(), иначе холст сбросится и на проверку пойдёт пустой.
Решение будет протестировано на двух наборах тестов. В случае ошибок на первом наборе вы сможете увидеть данные теста, данные вторых тестов скрыты. Итоговые баллы выставляются за каждый пройденный тест.
















C. YouTube 2
Ограничение времени	5 секунд
Ограничение памяти	512.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Сложная часть (необходимо на "отл")

В данной задаче вам нужно будет продолжить анализ данных о видео на YouTube. Информация об имени категории видео содержится в файле RU_category_id.json. Код для чтения этого файла и извлечения из него необходимой информации в виде pandas-таблицы уже написан в шаблоне решения.

Задача состоит из 6 пунктов, под каждый из которых предусмотрена соответствующая функция в классе YouTube2:

Загрузите датасет с данными о видео в российском сегменте Youtube. Код для формирования таблицы с категориями уже написан. При считывании таблицы trends_df не забудьте правильно распознать дату.
Объедините две таблицы на основе индекса категории. Это можно сделать с помощью метода merge. Далее используйте названия категорий, а не id.
Составьте сводную таблицу о количестве просмотров по дням для каждой категории видео с помощью функции pivot_table. Пропуски заменять не нужно.
Визуализируйте таблицу с помощью heatmap. Для информативности поделите все числа на 10^6 и не забудьте про подписи в клетках heatmap.
Сделайте аналогичную сводную таблицу, добавив суммы по строкам и столбцам, назвав их "Всего просмотров". Пропуски заменять не нужно.
Визуализируйте таблицу с помощью heatmap. Для информативности поделите все числа на 10^6.
При построении, аналогичном пункту 3, график получается неинформативным. Вам нужно это исправить.
Шаблон решения:

import json
import typing as tp

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from datetime import datetime
from matplotlib.figure import Figure


class YouTube2:
    def __init__( # task0
        self,
        trends_df_path: str="RUvideos_short.csv",
        categories_df_path: str="RU_category_id.json"
    ):
      self.trends_df = # read trends df

      with open(categories_df_path) as json_file:
          json_data = json.load(json_file)
          
      self.categories_df = pd.DataFrame(columns=['id', 'name'])

      for item in json_data['items']:
          self.categories_df = self.categories_df.append(
              {'id': int(item['id']),
              'name': item['snippet']['title']},
              ignore_index=True
          )
          
      self.categories_df['id'] = self.categories_df['id'].astype(int)


    def task1(self) -> pd.DataFrame:
      return ...
    

    def task2(self) -> pd.DataFrame:
      return ...


    def task3(self) -> Figure:
      ...
      return plt.gcf()


    def task4(self) -> pd.DataFrame:
      return ...


    def task5(self) -> Figure:
      ...
      return plt.gcf()
Присылать нужно только код класса с подключением необходимых библиотек. Использовать библиотеки, которых нет в шаблоне, запрещается.
Во время тестирования создается только один объект класса решения. Все подзадачи запускаются по порядку.
Все функции для пунктов с графиками должны возвращать matplotlib.figure.Figure, на котором рисовался график. В шаблоне уже есть пример как это сделать через plt.gcf(), но при этом нельзя вызывать plt.show(), иначе холст сбросится и на проверку пойдёт пустой.
Решение будет протестировано на двух наборах тестов. В случае ошибок на первом наборе вы сможете увидеть данные теста, данные вторых тестов скрыты. Итоговые баллы выставляются за каждый пройденный тест.
